# 享元（蝇量）模式

通过共享对象来减少系统种对象的数量，其本质就是缓存共享对象，降低内存消耗。  
享元模式将需要重复使用的对象分为两个部分：内部状态和外部状态。  
内部状态是不会变化的，可以被多个对象共享，而外部状态会随着对象的使用而改变。  
比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态。


## 对象角色
* 抽象享元角色(FlyWeight)：享元对象抽象基类或者接口,同时定义出对象的外部状态和内部状态的接口或实现
* 具体享元角色(ConcreteFlyWeight)：实现抽象享元类中的方法，是需要共享的对象类
* 享元工厂(FlyWeightFactory)：维护一个享元对象的池，内部使用一个 Map 存储已经创建的享元对象

## 优点

* 共享大量相似对象，可以避免大量无谓的内存分配和释放操作，缓解垃圾回收器的压力，提高吞吐量。
* 避免对象的重复创建，尤其是在创建大量具有相同属性的对象时，使用享元模式可以大大提高系统的性能和效率，避免出现大量的重复对象占用内存空间，降低系统开销。
* 享元模式的内部状态和外部状态是分离的，内部状态存储在内存中，外部状态可以根据需要进行传递，这样可以有效地降低对象间的耦合度。
* 共享的对象能够在多个线程中安全地共享并发访问，不会有线程安全问题。

## 缺点

* 实现比较复杂。在实际开发中，需要对内部状态和外部状态进行较为繁琐的区分。
* 过度共享。如果对象的内部和外部状态没有分清，或者没有合理地设计，可能会导致系统过度共享，导致共享的对象过多。
* 增加代码的复杂度。程序员必须时刻根据系统的实际情况以及内部状态和外部状态的不同选择使用对象池或享元工厂来管理内存和共享对象，进一步增加了系统的复杂度。

## java应用
* String类型字符串常量池，相同的字符串之创建一次进行缓存
* Integer类型对常用数字（-127~128）进行缓存
* 数据库连接池对连接进行复用
* 线程池对线程进行复用
## 场景
* 共享单车  
  在共享单车系统中，每辆车可以看做是一个享元对象。共享的部分是单车的基本属性，比如颜色、价格、型号等。相同型号、价格、颜色的单车可以共享同一个对象，不需要每次创建新的对象
* 车票预定  
  在一个车站的车票预订系统中，有许多订票窗口，每个窗口可以处理多个订票请求。每个订票请求都可以看作一个享元对象，而订票窗口可以看作是“享元工厂”。订票窗口根据请求的参数来创建或共享对象，避免创建过多的重复对象，提高了系统的性能。
* 汉字输入法  
  在汉字输入法中，由于汉字数量很多，为了避免重复创建，使用享元模式，即相同的汉字只需要在内存中创建一次，这样就大大减少了内存的消耗，也加快了输入法的执行速度。


享元模式其实就是工厂模式的一个改进机制，享元模式同样要求创建一个或一组对象，并且就是通过工厂方法生成对象的，不同的地方在于享元模式增加了**缓存**的功能