# 单例模式
某个类只能有一个实例，提供一个全局的访问点。

## 要点
某个类只能有一个实例；  
它必须自行创建这个实例；  
它必须自行向整个系统提供这个实例。
## 优点
全局唯一实例，节省内存，减少了实例个数，有利于JVM GC操作。
## 缺点
不适用于变化的对象，如果同一类型的对象在不同场景，其状态发生变化，那么单例模式就无法支持。

## 构建步骤
* 构造方法私有化
* 类中自己构建自己
* 提供一个公共的 getInstance() 方法供调用

## 实现方式
* 饿汉式  
  优点：一般使用static和final修饰变量，只在类加载时才会初始化，以后都不会，线程绝对安全，无锁，效率高  
  缺点：类加载的时候就初始化，不管用不用，都占用空间，会消耗一定的性能(当然很小很小，几乎可以忽略不计，所以这种模式在很多场合十分常用而且十分简单)
* 懒汉式  
  优点：外部使用时才初始化，不占用空间  
  缺点：线程不安全，假设当前有N个线程同时调用getInstance（）方法，由于当前还没有对象生成，所以一部分同时都进入if语句new Singleton(),那么就会由多个线程创建多个多个user对象
* 懒汉式（线程安全）  
  优点：解决了懒汉式线程不安全的问题(synchronized锁)  
  缺点：线程阻塞，影响性能
* DCL单例-性能高的懒汉式  
  优点：解决了线程阻塞的问题  
  缺点：多个线程第一次进入的时候会造成大量的线程阻塞，代码不够优雅
* 静态内部类  
  优点：第一次类创建的时候加载，避免了内存浪费，不存在阻塞问题，线程安全，唯一性  
  缺点：序列化-漏洞：反射，会破坏内部类单例模式
* 枚举单例  
  单元素的枚举类型已经成为实现Singleton的最佳方法，无法反射创建对象，但是特殊的饿汉式。
* 静态内部类PLUS（借鉴枚举单例）  
  第一次类创建的时候加载，避免了内存浪费，不存在阻塞问题，线程安全，唯一性，解决了反射会破坏内部类单例模式的问题
* 容器式单例  
  Spring ioc 单例 是懒汉式 枚举上的升级
* ThreadLocal单例  
  ThreadLocal的作用呢，是提供线程内的局部变量，在多线程环境访问时，能保证各个线程内的ThreadLocal变量各自独立。也就是说每个线程的ThreadLocal变量是自己专用的，其他线程是访问不到的  
  ThreadLocal最常用于在多线程环境下存在对非线程安全对象的并发访问，而且该对象不需要在线程内共享，如果对该对象加锁，会造成大量线程阻塞影响程序性能，这时候就可以使用ThreadLocal来使每个线程都持有该对象的副本，这是典型的空间换取时间从而提高执行效率的方式。例如项目里经常使用的SimpleDateFormat日期格式化对象，该对象是线程不安全的，而且不需要在线程内共享，因此可以使用ThreadLocal保证其线程安全。