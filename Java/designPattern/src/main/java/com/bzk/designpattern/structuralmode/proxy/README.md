# 代理模式

为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性

## 工厂方法有四个对象

1. 一个抽象目标类/目标接口，定义了业务实现类和代理类的共有接口
2. 一个或者多个业务实体类，实现业务类接口，内部是具体的实现逻辑
3. 一个代理类，实现了业务类接口，关联了具体业务实现类，客户端通过代理类来访问具体业务实现类中的逻辑。
4. 代理类可以在具体业务类的基础上附加其他的逻辑


## 优点
满足开闭原则：  
①真实业务类内部修改关闭  
②真实业务类模块扩展功能开放: 代理类扩展真实业务类  
③实现了客户类依赖代理类处理或扩展真实业务类  
## 缺点
增加了系统的复杂度

## 静态代理
在编译时就已经实现了，编译完成后代理类是一个实际的class文件。
## 动态代理
动态地在内存中构建代理对象，从而实现对目标对象的代理功能。
（动态代理是运行时动态生成，即编译完成后没有实际 的class文件，而是在运行时动态生成类字节码，并加载到JVM中。）
### Java中的应用
* JDK动态代理  
  对接口创建代理，使用反射包中的Proxy和InvocationHandler来完成。
  1. 拿到被代理对象的引用，然后获取他的接口
  2. JDK代理重新生成一个类，同时实现我们给的代理对象所实现的接口
  3. 把被代理对象的引用拿到了
  4. 重新动态生成一个class字节码
  5. 然后编译
* CGLib动态代理  
  一种基于字节码增强的动态代理技术，它可以对任意类进行代理，不需要被代理的类实现接口。CGLIB动态代理的原理是通过ASM字节码框架生成目标类的子类，并覆盖其中方法实现增强。  
  CGLIB动态代理使用net.sf.cglib.proxy.MethodInterceptor接口作为拦截器，用于拦截目标类方法调用。  
  使用net.sf.cglib.proxy.Enhancer来创建代理对象。  
  CGLIB 创建动态代理类的模式是：
  1. 查找目标类上的所有非final 的public类型的方法定义；
  2. 将这些方法的定义转换成字节码；
  3. 将组成的字节码转换成相应的代理的class对象；
  4. 实现 MethodInterceptor接口，用来处理对代理类上所有方法的请求
* CGLib之FastClass机制  
  FastClass机制是一种优化CGLIB动态代理调用效率的技术，它的原理是为代理类和被代理类各生成一个FastClass类，这个类会为代理类或被代理类的方法分配一个索引，然后通过索引来直接调用相应的方法，避免了反射调用。
  

两者比较：  
JDK原生动态代理是面向接口的，也就是说被代理的类必须实现一个或多个接口，CGLIB动态代理是通过字节码底层继承要代理的类来实现，因此如果被代理的类被final关键字所修饰，会失败

JDK原生动态代理是通过反射机制生成一个实现了被代理对象接口的新类。CGLIB动态代理是通过ASM字节码框架生成目标类的子类

JDK原生动态代理使用java.lang.reflect.InvocationHandler接口作为拦截器，用于处理代理对象的方法调用。CGLIB动态代理使用net.sf.cglib.proxy.MethodInterceptor接口作为拦截器，用于拦截目标类方法调用

JDK Proxy 的优势：
最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。
平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。
代码实现简单。

基于类似 cglib 框架的优势：
无需实现接口，达到代理类无侵入
只操作我们关心的类，而不必为其他相关类增加工作量。
高性能

## 应用场景
* 功能增强  
  当需要对一个对象的访问提供一些额外操作时，可以使用代理模式
* 远程代理  
  实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。
  通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。
  除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。
* 防火墙代理  
  当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器
* 保护代理  
  控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。
