# 代理模式

为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性

## 工厂方法有四个对象

1. 一个抽象目标类/目标接口，定义了业务实现类和代理类的共有接口
2. 一个或者多个业务实体类，实现业务类接口，内部是具体的实现逻辑
3. 一个代理类，实现了业务类接口，关联了具体业务实现类，客户端通过代理类来访问具体业务实现类中的逻辑。
4. 代理类可以在具体业务类的基础上附加其他的逻辑


## 优点
满足开闭原则：  
①真实业务类内部修改关闭  
②真实业务类模块扩展功能开放: 代理类扩展真实业务类  
③实现了客户类依赖代理类处理或扩展真实业务类  
## 缺点
增加了系统的复杂度

## 静态代理
在编译时就已经实现了，编译完成后代理类是一个实际的class文件。
## 动态代理
动态地在内存中构建代理对象，从而实现对目标对象的代理功能。
（动态代理是运行时动态生成，即编译完成后没有实际 的class文件，而是在运行时动态生成类字节码，并加载到JVM中。）
### Java中的应用
* JDK动态代理
* CGLib动态代理

## 应用场景
* 功能增强  
  当需要对一个对象的访问提供一些额外操作时，可以使用代理模式
* 远程代理  
  实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。
  通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。
  除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。
* 防火墙代理  
  当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器
* 保护代理  
  控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。
